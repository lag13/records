package main

import (
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/lag13/records/internal/parsefile"
	"github.com/lag13/records/internal/person"
)

func contains(xs []string, y string) bool {
	for _, x := range xs {
		if x == y {
			return true
		}
	}
	return false
}

func main() {
	// TODO: I think by using the FlagSet struct this flag parsing
	// logic could be put into a package and unit tested. Consider
	// if this is worth doing or not.
	sortStyle := flag.String("sort", person.SortStyles[0], fmt.Sprintf("how to sort the data, the possible values are %s", strings.Join(person.SortStyles, ", ")))
	flag.Parse()
	if !contains(person.SortStyles, *sortStyle) {
		// TODO: Wording similar to this is auto-generated by
		// the flag parsing package if you do something like
		// make an int flag and pass it "asdf". I would prefer
		// to leverage the flag package rather than having to
		// emulate it myself here. How can we do that?
		// Additionally when flag parsing fails it exits with
		// a non-zero exit code and the message gets printed
		// to stderr (by default). I don't want to have to
		// duplicate that stuff either.
		fmt.Printf("invalid value %q for flag -sort\n", *sortStyle)
		flag.Usage()
		return
	}
	persons := []person.Person{}
	parseErrs := []string{}
	// parse each file. TODO: This is getting QUITE messy and
	// feels a little too complicated for being in main. I'm
	// thinking that I should break this up into separate
	// structural parsing and semantic parsing portions. Or
	// perhaps I'll try to move the code around a little (maybe
	// make a new unit that can be unit tested?). But! tests pass
	// so at least we can refactor with a little confidence.
	{
		for _, fileName := range flag.Args() {
			fh, err := os.Open(fileName)
			defer func(fh *os.File) {
				if fh == nil {
					return
				}
				_ = fh.Close()
			}(fh)
			lines, parseErr := parsefile.ParseFile(parsefile.File{
				Name:    fileName,
				Content: fh,
				OpenErr: err,
			})
			if parseErr != "" {
				parseErrs = append(parseErrs, parseErr)
				continue
			}
			for i, line := range lines {
				p, semParseErrs := person.Parse(line)
				annotatedSemParseErrs := []string{}
				for _, semParseErr := range semParseErrs {
					annotatedSemParseErrs = append(annotatedSemParseErrs, fmt.Sprintf("%s:%d: %s", fileName, i+1, semParseErr))
				}
				parseErrs = append(parseErrs, annotatedSemParseErrs...)
				persons = append(persons, p)
			}
		}
	}
	if len(parseErrs) > 0 {
		// TODO: Should this print to stderr and return a
		// non-zero exit code? I'm thinking yes.
		fmt.Println("Invalid Input:")
		fmt.Println(strings.Join(parseErrs, "\n"))
		return
	}
	person.Sort(*sortStyle, persons)
	for _, p := range persons {
		fmt.Println(person.Marshal(p))
	}
}
